<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFS SpeedTest</title>
    <script src="../../lib/chart.js"></script>
    <style>
        :root {
            --primary: #4361ee;
            --primary-dark: #3a56d4;
            --secondary: #7209b7;
            --success: #06d6a0;
            --danger: #ef476f;
            --dark: #1a1a2e;
            --light: #f8f9fa;
            --gray: #6c757d;
            --card-bg: #ffffff;
            --card-shadow: 0 10px 30px rgba(0,0,0,0.08);
            --border-radius: 16px;
            
            --text-primary: #333;
            --text-secondary: #6c757d;
            --body-bg: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            --ip-container-bg: rgba(67, 97, 238, 0.08);
            --ip-row-border: 1px solid rgba(0,0,0,0.05);
            --progress-bg: #edf2f7;
            --metric-card-shadow: 0 5px 15px rgba(0,0,0,0.05);
            --chart-card-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --primary: #5e7cff;
                --primary-dark: #4c6bff;
                --secondary: #9d4edd;
                --success: #06d6a0;
                --danger: #ff6b8b;
                --dark: #f8f9fa;
                --light: #1a1a2e;
                --gray: #a0aec0;
                --card-bg: #1e1e2e;
                --card-shadow: 0 10px 30px rgba(0,0,0,0.3);
                
                --text-primary: #e2e8f0;
                --text-secondary: #a0aec0;
                --body-bg: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                --ip-container-bg: rgba(94, 124, 255, 0.15);
                --ip-row-border: 1px solid rgba(255,255,255,0.05);
                --progress-bg: #2d3748;
                --metric-card-shadow: 0 5px 15px rgba(0,0,0,0.2);
                --chart-card-shadow: 0 5px 15px rgba(0,0,0,0.2);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--body-bg);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
        }

        .speedtest-card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            overflow: hidden;
            padding: 30px;
        }

        .ip-container {
            background: var(--ip-container-bg);
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 30px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .ip-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: var(--ip-row-border);
        }
        
        .ip-row:last-child {
            border-bottom: none;
        }

        .ip-content {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ip-content .icon {
            background: var(--primary);
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .ip-content .value {
            font-weight: 600;
            font-size: 1.05rem;
            color: var(--dark);
        }

        .test-controls {
            text-align: center;
            margin: 30px 0;
        }

        .btn {
            padding: 16px 40px;
            font-size: 1.1rem;
            font-weight: 600;
            border-radius: 50px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(67, 97, 238, 0.3);
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 20px rgba(67, 97, 238, 0.4);
        }

        .btn-primary:active {
            transform: translateY(1px);
        }

        .btn-primary:disabled {
            background: #e0e0e0;
            color: #a0a0a0;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #f0f2f5;
            color: var(--gray);
            margin-left: 10px;
        }

        @media (prefers-color-scheme: dark) {
            .btn-secondary {
                background: #2d3748;
                color: var(--gray);
            }
        }

        .progress-container {
            height: 8px;
            background: var(--progress-bg);
            border-radius: 4px;
            overflow: hidden;
            margin: 30px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.4s ease;
        }

        .status {
            text-align: center;
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin: 15px 0 30px;
            min-height: 28px;
        }

        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .metric-card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 25px;
            box-shadow: var(--metric-card-shadow);
            transition: transform 0.3s ease;
            text-align: center;
        }

        .metric-card:hover {
            transform: translateY(-5px);
        }

        .metric-card.ping {
            border-top: 4px solid var(--primary);
        }

        .metric-card.download {
            border-top: 4px solid var(--success);
        }

        .metric-card.upload {
            border-top: 4px solid #ff9e00;
        }

        .metric-title {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .metric-value {
            font-size: 2.2rem;
            font-weight: 700;
            margin: 10px 0;
            color: var(--dark);
        }

        .metric-unit {
            font-size: 1rem;
            color: var(--text-secondary);
        }

        .latency-container {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
        }

        .latency-item {
            text-align: center;
        }

        .latency-title {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .latency-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--dark);
        }

        .latency-unit {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }

        .chart-card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--chart-card-shadow);
        }

        .chart-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .chart-container {
            height: 250px;
            width: 100%;
        }

        @media (max-width: 1280px) {
            body {
                padding-top: 10px;
            }
            
            .speedtest-card {
                padding: 10px 30px 30px;
            }

            .ip-container {
                padding: 0;
                margin-bottom: 0;
                row-gap: 2px;
            }

            .ip-content .icon {
                width: 26px;
                height: 26px;
                font-size: 10px;
                flex-shrink: 0;
            }
            
            .ip-row {
                padding: 2px 0;
            }

            .test-controls {
                margin: 5px 0;
            }
            
            .progress-container {
                margin: 5px 0;
            }
            
            .status {
                margin: 5px 0;
            }

            .results-grid {
                gap: 2px;
                margin-top: 2px;
                grid-template-columns: 1fr 1fr;
            }
            
            .metric-card.ping {
                grid-column: 1 / 3;
                display: flex;
                justify-content: center;
                padding: 0 5px;
            }

            .latency-container {
                margin-top: 0;
            }

            .latency-item {
                padding: 0 45px;
            }

            .latency-title {
                margin-bottom: 0;
            }

            .metric-title {
                display: none;
                margin: 0;
            }

            .metric-card.download {
                grid-row: 2;
                grid-column: 1;
                padding: 0 1px;
            }
            
            .metric-card.upload {
                grid-row: 2;
                grid-column: 2;
                padding: 0 1px;
            }

            .metric-value {
                margin: 0;
            }

            .charts-container {
                padding: 0;
                margin-top: 2px;
                row-gap: 2px;
                grid-template-columns: 1fr;
            }
            
            .chart-card {
                padding: 0;
            }
            
            .chart-title {
                margin-bottom: 0;
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 1.5s infinite;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="speedtest-card">
            <div class="ip-container">
                <div class="ip-row">
                    <div class="ip-content">
                        <div class="icon">IPv4</div>
                        <div class="value" id="ipv4Value">Detecting...</div>
                    </div>
                </div>
                <div class="ip-row">
                    <div class="ip-content">
                        <div class="icon">IPv6</div>
                        <div class="value" id="ipv6Value">Detecting...</div>
                    </div>
                </div>
            </div>
            
            <div class="test-controls">
                <button id="startTest" class="btn btn-primary pulse">Start</button>
                <button id="stopTest" class="btn btn-secondary" disabled>Stop</button>
            </div>
            
            <div class="progress-container">
                <div id="progressBar" class="progress-bar"></div>
            </div>
            
            <div id="status" class="status">Ready to start</div>
            
            <div class="results-grid" id="results" style="display: none;">
                <div class="metric-card ping">
                    <h3 class="metric-title">Ping & Jitter</h3>
                    <div class="latency-container">
                        <div class="latency-item">
                            <div class="latency-title">Ping</div>
                            <div class="latency-value" id="pingValue">0.00</div>
                            <div class="latency-unit">ms</div>
                        </div>
                        <div class="latency-item">
                            <div class="latency-title">Jitter</div>
                            <div class="latency-value" id="jitterValue">0.00</div>
                            <div class="latency-unit">ms</div>
                        </div>
                    </div>
                </div>
                
                <div class="metric-card download">
                    <h3 class="metric-title">Download</h3>
                    <div class="metric-value" id="downloadValue">0.00</div>
                    <div class="metric-unit">Mbit/s</div>
                </div>
                
                <div class="metric-card upload">
                    <h3 class="metric-title">Upload</h3>
                    <div class="metric-value" id="uploadValue">0.00</div>
                    <div class="metric-unit">Mbit/s</div>
                </div>
            </div>
            
            <div class="charts-container" id="charts" style="display: none;">
                <div class="chart-card">
                    <h3 class="chart-title">Download speed</h3>
                    <div class="chart-container">
                        <canvas id="downloadChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-card">
                    <h3 class="chart-title">Upload speed</h3>
                    <div class="chart-container">
                        <canvas id="uploadChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
    const startBtn = document.getElementById('startTest');
    const stopBtn = document.getElementById('stopTest');
    const resultsDiv = document.getElementById('results');
    const chartsDiv = document.getElementById('charts');
    const progressBar = document.getElementById('progressBar');
    const statusEl = document.getElementById('status');
    const downloadValue = document.getElementById('downloadValue');
    const uploadValue = document.getElementById('uploadValue');
    const pingValue = document.getElementById('pingValue');
    const jitterValue = document.getElementById('jitterValue');
    const ipv4Value = document.getElementById('ipv4Value');
    const ipv6Value = document.getElementById('ipv6Value');
    
    const settings = window.speedtestSettings || {
        testDuration: 5,
        pingCount: 10,
        enableGeoIP: false
    };
    
    const CALIBRATION_SIZE = 1 * 1024 * 1024;
    const MIN_CHUNK_SIZE = 50 * 1024;
    const MAX_CHUNK_SIZE = 100 * 1024 * 1024;
    const TARGET_UPDATES_PER_SECOND = 2;
    const UPDATE_INTERVAL = 1000 / TARGET_UPDATES_PER_SECOND;
    
    let downloadData = [];
    let uploadData = [];
    let downloadChart = null;
    let uploadChart = null;
    let testActive = false;
    let medianPing = 0;

    function updateProgress(percent, text) {
        progressBar.style.width = `${percent}%`;
        statusEl.textContent = text;
    }
    
    function getFlagEmoji(countryCode) {
        if (!countryCode) return '';
        const codePoints = countryCode
            .toUpperCase()
            .split('')
            .map(char => 127397 + char.charCodeAt());
        return String.fromCodePoint(...codePoints);
    }
    
    function isLocalIP(ip) {
        if (!ip) return false;
        if (ip === '127.0.0.1' || ip === '::1') return true;
        
        if (ip.includes('.')) {
            const parts = ip.split('.');
            if (parts[0] === '10') return true;
            if (parts[0] === '192' && parts[1] === '168') return true;
            if (parts[0] === '172' && parseInt(parts[1]) >= 16 && parseInt(parts[1]) <= 31) return true;
        }
        
        if (ip.includes(':') && !ip.includes('.')) {
            if (ip.startsWith('fc') || ip.startsWith('fd')) return true;
            if (ip.startsWith('fe80:')) return true;
        }
        
        return false;
    }
    
    async function getPublicIP(version = 4) {
        try {
            const service = version === 4 
                ? 'https://api.ipify.org?format=json' 
                : 'https://api64.ipify.org?format=json';
            
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 3000);
            
            const response = await fetch(service, { signal: controller.signal });
            clearTimeout(timeout);
            const data = await response.json();
            return data.ip;
        } catch (e) {
            console.error(`Failed to get public IPv${version}:`, e);
            return null;
        }
    }
    
    async function getIPv6() {
        try {
            const response = await fetch('https://api6.ipify.org?format=json', { 
                signal: AbortSignal.timeout(3000) 
            });
            const data = await response.json();
            return data.ip;
        } catch (e) {
            console.error('Failed to get IPv6:', e);
            return null;
        }
    }
    
async function getClientIP() {
    try {
        const response = await fetch('/~/ip');
        const data = await response.json();
        
        let ipv4 = null;
        let ipv6 = null;
        
        if (data.ip) {
            if (data.ip.includes('.')) {
                ipv4 = data.ip;
            } else if (data.ip.includes(':')) {
                ipv6 = data.ip;
            }
        }
        
        if (data.ips && data.ips.length > 0) {
            for (const ip of data.ips) {
                if (ip.includes('.') && !ipv4) {
                    ipv4 = ip;
                } else if (ip.includes(':') && !ip.includes('.') && !ipv6) {
                    ipv6 = ip;
                }
            }
        }
        
        const isLocalIPv4 = isLocalIP(ipv4);
        const isLocalIPv6 = isLocalIP(ipv6);
        
        if (!ipv6 && !isLocalIPv4 && !isLocalIPv6) {
            const detectedIPv6 = await getIPv6();
            if (detectedIPv6 && detectedIPv6.includes(':') && !detectedIPv6.includes('.')) {
                ipv6 = detectedIPv6;
            }
        }
        
        if (ipv4) {
            ipv4Value.textContent = `IPv4: ${ipv4}`;
            if (settings.enableGeoIP && !isLocalIPv4) {
                await updateGeoInfo(ipv4, ipv4Value);
            } else if (isLocalIPv4) {
                ipv4Value.textContent += ' | Local IP';
            }
        } else if (settings.useExternalForNotDetected) {
            ipv4Value.textContent = 'IPv4: Getting public IP...';
            const publicIPv4 = await getPublicIP(4);
            if (publicIPv4) {
                ipv4Value.textContent = `IPv4: ${publicIPv4}`;
                if (settings.enableGeoIP) await updateGeoInfo(publicIPv4, ipv4Value);
            } else {
                ipv4Value.textContent = 'IPv4: Not detected';
            }
        } else {
            ipv4Value.textContent = 'IPv4: Not detected';
        }
        
        if (ipv6) {
            const cleanIPv6 = ipv6.replace(/^::ffff:/, '');
            if (cleanIPv6.includes('.')) {
                ipv6Value.textContent = 'IPv6: Not detected';
            } else {
                ipv6Value.textContent = `IPv6: ${cleanIPv6}`;
                if (settings.enableGeoIP && !isLocalIPv6) {
                    await updateGeoInfo(cleanIPv6, ipv6Value);
                } else if (isLocalIPv6) {
                    ipv6Value.textContent += ' | Local IP';
                }
            }
        } else if (settings.useExternalForNotDetected) {
            ipv6Value.textContent = 'IPv6: Getting public IP...';
            const publicIPv6 = await getPublicIP(6);
            if (publicIPv6 && publicIPv6.includes(':') && !publicIPv6.includes('.')) {
                ipv6Value.textContent = `IPv6: ${publicIPv6}`;
                if (settings.enableGeoIP) await updateGeoInfo(publicIPv6, ipv6Value);
            } else {
                ipv6Value.textContent = 'IPv6: Not detected';
            }
        } else {
            ipv6Value.textContent = 'IPv6: Not detected';
        }
        
        if ((isLocalIPv4 || isLocalIPv6) && settings.useExternalForLocal) {
            if (isLocalIPv4) {
                ipv4Value.textContent = 'IPv4: Getting public IP...';
                const publicIPv4 = await getPublicIP(4);
                if (publicIPv4) {
                    ipv4Value.textContent = `IPv4: ${publicIPv4}`;
                    if (settings.enableGeoIP) await updateGeoInfo(publicIPv4, ipv4Value);
                }
            }
            
            if (isLocalIPv6) {
                ipv6Value.textContent = 'IPv6: Getting public IP...';
                const publicIPv6 = await getPublicIP(6);
                if (publicIPv6 && publicIPv6.includes(':') && !publicIPv6.includes('.')) {
                    ipv6Value.textContent = `IPv6: ${publicIPv6}`;
                    if (settings.enableGeoIP) await updateGeoInfo(publicIPv6, ipv6Value);
                }
            }
        }
        
    } catch (e) {
        console.error('IP detection error:', e);
        ipv4Value.textContent = 'IPv4: Unavailable';
        ipv6Value.textContent = 'IPv6: Unavailable';
    }
}
    
    async function updateGeoInfo(ip, element) {
        try {
            if (isLocalIP(ip)) {
                element.textContent += ' | Local IP';
                return;
            }
            
            const cacheKey = `hfs-geo-${ip}`;
            const cachedGeo = localStorage.getItem(cacheKey);
            if (cachedGeo) {
                element.textContent += ` | ${cachedGeo}`;
                return;
            }
            
            const geoResponse = await fetch(`https://ipwho.is/${ip}`);
            if (!geoResponse.ok) throw new Error('GeoIP service failed');
            const geoData = await geoResponse.json();
            
            let geoText = '';
            if (geoData.country) {
                const flag = getFlagEmoji(geoData.country_code);
                if (flag) geoText += ` ${flag} `;
                geoText += geoData.country;
            }
            if (geoData.city) geoText += `, ${geoData.city}`;
            
            if (geoText) {
                element.textContent += ` | ${geoText}`;
                localStorage.setItem(cacheKey, geoText);
                const expiration = new Date();
                expiration.setDate(expiration.getDate() + 7);
                localStorage.setItem(`${cacheKey}_exp`, expiration.toISOString());
            }
        } catch (e) {
            console.error('GeoIP error:', e);
            element.textContent += ' | Location: Unknown';
        }
    }
    
    function initCharts() {
        if (downloadChart) downloadChart.destroy();
        if (uploadChart) uploadChart.destroy();
        
        const downloadCtx = document.getElementById('downloadChart').getContext('2d');
        downloadChart = new Chart(downloadCtx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Download (Mbit/s)',
                    data: downloadData,
                    borderColor: '#06d6a0',
                    backgroundColor: 'rgba(6, 214, 160, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 6,
                    pointBackgroundColor: '#06d6a0',
                    pointBorderColor: '#ffffff',
                    pointBorderWidth: 2,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    tooltip: {
                        displayColors: false,
                        callbacks: {
                            label: context => {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} Mbit/s`;
                            }
                        }
                    },
                    legend: { display: false }
                },
                scales: {
                    y: { 
                        beginAtZero: true,
                        title: { 
                            display: true, 
                            text: 'Mbit/s',
                            font: { weight: 'bold' }
                        },
                        grid: { color: 'rgba(0,0,0,0.05)' }
                    },
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: { 
                            display: true, 
                            text: 'Time (sec)',
                            font: { weight: 'bold' }
                        },
                        grid: { display: false },
                        ticks: {
                            callback: value => {
                                return value % 1 === 0 ? value : value.toFixed(1);
                            }
                        }
                    }
                },
                animation: false
            }
        });
        
        const uploadCtx = document.getElementById('uploadChart').getContext('2d');
        uploadChart = new Chart(uploadCtx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Upload (Mbit/s)',
                    data: uploadData,
                    borderColor: '#ff9e00',
                    backgroundColor: 'rgba(255, 158, 0, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 6,
                    pointBackgroundColor: '#ff9e00',
                    pointBorderColor: '#ffffff',
                    pointBorderWidth: 2,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    tooltip: {
                        displayColors: false,
                        callbacks: {
                            label: context => {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} Mbit/s`;
                            }
                        }
                    },
                    legend: { display: false }
                },
                scales: {
                    y: { 
                        beginAtZero: true,
                        title: { 
                            display: true, 
                            text: 'Mbit/s',
                            font: { weight: 'bold' }
                        },
                        grid: { color: 'rgba(0,0,0,0.05)' }
                    },
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: { 
                            display: true, 
                            text: 'Time (sec)',
                            font: { weight: 'bold' }
                        },
                        grid: { display: false },
                        ticks: {
                            callback: value => {
                                return value % 1 === 0 ? value : value.toFixed(1);
                            }
                        }
                    }
                },
                animation: false
            }
        });
    }
    
    function adjustDownloadChartScale() {
        if (downloadChart && downloadChart.data.datasets[0].data.length > 0) {
            const downloadDataPoints = downloadChart.data.datasets[0].data;
            const maxX = Math.max(...downloadDataPoints.map(point => point.x));
            downloadChart.options.scales.x.max = maxX * 1.001, 0.5;
            downloadChart.update('none');
        }
    }
    
    function adjustUploadChartScale() {
        if (uploadChart && uploadChart.data.datasets[0].data.length > 0) {
            const uploadDataPoints = uploadChart.data.datasets[0].data;
            const maxX = Math.max(...uploadDataPoints.map(point => point.x));
            uploadChart.options.scales.x.max = maxX * 1.001, 0.5;
            uploadChart.update('none');
        }
    }

    async function testLatency() {
        const times = [];
        updateProgress(15, 'Measuring ping...');
        const pingCount = settings.pingCount || 10;
        
        for (let i = 0; i < pingCount; i++) {
            if (!testActive) return 0;
            
            const start = performance.now();
            try {
                await fetch('/~' + Math.random(), {
                    headers: { 
                        'Cache-Control': 'no-cache',
                        'X-SpeedTest': 'ping'
                    }
                });
                const latency = performance.now() - start;
                times.push(latency);
            } catch (e) {
                console.error('Ping error:', e);
            }
            
            await new Promise(r => setTimeout(r, 300));
        }
        
        if (times.length === 0) return 0;
        
        const sortedTimes = [...times].sort((a, b) => a - b);
        let median;
        const mid = Math.floor(sortedTimes.length / 2);
        if (sortedTimes.length % 2 === 0) {
            median = (sortedTimes[mid - 1] + sortedTimes[mid]) / 2;
        } else {
            median = sortedTimes[mid];
        }
        
        let jitterTimes = times;
        if (times.length > 1) {
            jitterTimes = times.slice(1);
        }
        
        const minPing = Math.min(...jitterTimes);
        const maxPing = Math.max(...jitterTimes);
        const jitter = maxPing - minPing;
        
        pingValue.textContent = median.toFixed(2);
        jitterValue.textContent = jitter.toFixed(2);
        
        return median;
    }
    
    function calculateChunkSize(speedBps) {
        if (speedBps <= 0) return MIN_CHUNK_SIZE;
        
        let chunkSize = speedBps / (8 * TARGET_UPDATES_PER_SECOND);
        
        return Math.round(Math.max(MIN_CHUNK_SIZE, Math.min(MAX_CHUNK_SIZE, chunkSize)));
    }
    
    async function performCalibration(direction, medianPing) {
        const STAGE_1_SIZE = 1 * 1024 * 1024;
        const STAGE_2_SIZE = 10 * 1024 * 1024;
        const SPEED_THRESHOLD = 2 * 1024 * 1024 * 8;
        
        let calibrationSize = STAGE_1_SIZE;
        let duration = 0;
        let speedBps = 0;
        let isSecondStage = false;
        
        updateProgress(
            direction === 'download' ? 20 : 25, 
            `Calibrating ${direction} (1MB)...`
        );
        
        if (direction === 'download') {
            duration = await sendDownloadCalibration(STAGE_1_SIZE);
        } else {
            duration = await sendUploadCalibration(STAGE_1_SIZE);
        }
        
        if (duration > 0) {
            const correctedDuration = Math.max(1, duration - medianPing);
            speedBps = (STAGE_1_SIZE * 8) / (correctedDuration / 1000);
        }
        
        if (duration < 500 && speedBps > SPEED_THRESHOLD) {
            isSecondStage = true;
            calibrationSize = STAGE_2_SIZE;
            
            updateProgress(
                direction === 'download' ? 21 : 26, 
                `High precision ${direction} calibration (10MB)...`
            );
            
            if (direction === 'download') {
                duration = await sendDownloadCalibration(STAGE_2_SIZE);
            } else {
                duration = await sendUploadCalibration(STAGE_2_SIZE);
            }
            
            if (duration > 0) {
                const correctedDuration = Math.max(1, duration - medianPing);
                speedBps = (STAGE_2_SIZE * 8) / (correctedDuration / 1000);
            }
        }
        
        return {
            speedBps,
            calibrationSize,
            isSecondStage
        };
    }

    async function sendDownloadCalibration(size) {
        try {
            const headers = { 
                'Cache-Control': 'no-cache',
                'X-SpeedTest': 'calibration',
                'X-Calibration-Size': size.toString()
            };
            
            const start = performance.now();
            const response = await fetch('/~calibration', { headers });
            await response.arrayBuffer();
            return performance.now() - start;
        } catch(e) { 
            console.error('Download calibration error:', e);
            return 0;
        }
    }
    
    async function sendUploadCalibration(size) {
        try {
            const chunk = new Uint8Array(size);
            const start = performance.now();
            await fetch('/~/upload-calibration', {
                method: 'POST',
                body: chunk,
                headers: { 
                    'Content-Type': 'application/octet-stream',
                    'X-SpeedTest': 'calibration'
                }
            });
            return performance.now() - start;
        } catch(e) { 
            console.error('Upload calibration error:', e);
            return 0;
        }
    }
    
    async function calibrateDownload(medianPing) {
        const result = await performCalibration('download', medianPing);
        return {
            chunkSizeBytes: calculateChunkSize(result.speedBps),
            updateInterval: UPDATE_INTERVAL,
            precision: result.isSecondStage ? 'high' : 'normal'
        };
    }
    
    async function calibrateUpload(medianPing) {
        const result = await performCalibration('upload', medianPing);
        return {
            chunkSizeBytes: calculateChunkSize(result.speedBps),
            updateInterval: UPDATE_INTERVAL,
            precision: result.isSecondStage ? 'high' : 'normal'
        };
    }

    function calculateMedian(values) {
        if (values.length === 0) return 0;
        
        const sortedValues = [...values].sort((a, b) => a - b);
        const mid = Math.floor(sortedValues.length / 2);
        
        return sortedValues.length % 2 !== 0 
            ? sortedValues[mid] 
            : (sortedValues[mid - 1] + sortedValues[mid]) / 2;
    }

    async function testDownload(params, medianPing) {
        const chunkSizeMB = (params.chunkSizeBytes / (1024 * 1024)).toFixed(1);
        updateProgress(30, `Chunk ${chunkSizeMB}MB - Testing download...`);
        
        const startTime = performance.now();
        const duration = (settings.testDuration || 5) * 1000;
        let totalBytes = 0;
        
        let lastBytes = 0;
        let lastTime = startTime;
        
        downloadData = [{x:0, y:0}];
        initCharts();
        if (downloadChart) downloadChart.update();
        
        const chunkSizeBytes = params.chunkSizeBytes;
        const updateInterval = params.updateInterval;
        let lastUpdate = 0;
        
        while (performance.now() - startTime < duration && testActive) {
            try {
                const response = await fetch('/~' + Math.random(), {
                    headers: { 
                        'Cache-Control': 'no-cache',
                        'X-SpeedTest': 'download',
                        'X-Chunk-Size': chunkSizeBytes.toString()
                    }
                });
                const data = await response.arrayBuffer();
                totalBytes += data.byteLength;
                
                const currentTime = performance.now();
                const elapsed = (currentTime - startTime) / 1000;
                
                const timeDelta = (currentTime - lastTime) / 1000;
                const bytesDelta = totalBytes - lastBytes;
                
                if (timeDelta > 0) {
                    const transferTime = Math.max(0.001, timeDelta - (medianPing / 1000));
                    const instantSpeedMbps = (bytesDelta * 8) / (transferTime * 1000 * 1000);
                    
                    if (currentTime - lastUpdate > updateInterval) {
                        downloadData.push({x: elapsed, y: instantSpeedMbps});
                        if (downloadChart) downloadChart.update();
                        downloadValue.textContent = instantSpeedMbps.toFixed(2);
                        lastUpdate = currentTime;
                    }
                    
                    lastBytes = totalBytes;
                    lastTime = currentTime;
                }
            } catch (e) {
                console.error('Download error:', e);
            }
        }
        
        if (downloadData.length > 0) {
            const speedValues = downloadData.slice(1).map(point => point.y);
            const medianSpeed = calculateMedian(speedValues);
            downloadValue.textContent = medianSpeed.toFixed(2);
            if (downloadChart) downloadChart.update();
        }
    }

    async function testUpload(params, medianPing) {
        const chunkSizeMB = (params.chunkSizeBytes / (1024 * 1024)).toFixed(1);
        updateProgress(70, `Chunk ${chunkSizeMB}MB - Testing upload...`);
        
        const startTime = performance.now();
        const duration = (settings.testDuration || 5) * 1000;
        let totalBytes = 0;
        
        let lastBytes = 0;
        let lastTime = startTime;
        
        uploadData = [{x:0, y:0}];
        initCharts();
        adjustDownloadChartScale();
        if (uploadChart) uploadChart.update();
        
        const chunkSizeBytes = params.chunkSizeBytes;
        const updateInterval = params.updateInterval;
        let lastUpdate = 0;
        
        while (performance.now() - startTime < duration && testActive) {
            try {
                const chunk = new Uint8Array(chunkSizeBytes);
                
                await fetch('/~/upload', {
                    method: 'POST',
                    body: chunk,
                    headers: { 
                        'Content-Type': 'application/octet-stream',
                        'X-SpeedTest': 'upload'
                    }
                });
                
                totalBytes += chunkSizeBytes;
                const currentTime = performance.now();
                const elapsed = (currentTime - startTime) / 1000;
                
                const timeDelta = (currentTime - lastTime) / 1000;
                const bytesDelta = totalBytes - lastBytes;
                
                if (timeDelta > 0) {
                    const transferTime = Math.max(0.001, timeDelta - (medianPing / 1000));
                    const instantSpeedMbps = (bytesDelta * 8) / (transferTime * 1000 * 1000);
                    
                    if (currentTime - lastUpdate > updateInterval) {
                        uploadData.push({x: elapsed, y: instantSpeedMbps});
                        if (uploadChart) uploadChart.update();
                        uploadValue.textContent = instantSpeedMbps.toFixed(2);
                        lastUpdate = currentTime;
                    }
                    
                    lastBytes = totalBytes;
                    lastTime = currentTime;
                }
            } catch (e) {
                console.error('Upload error:', e);
            }
        }
        
        if (uploadData.length > 0) {
            const speedValues = uploadData.slice(1).map(point => point.y);
            const medianSpeed = calculateMedian(speedValues);
            uploadValue.textContent = medianSpeed.toFixed(2);
            if (uploadChart) uploadChart.update();
            adjustUploadChartScale();
        }
    }
    
async function runSpeedTest() {
    if (testActive) return;
    
    try {
        testActive = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        resultsDiv.style.display = 'grid';
        chartsDiv.style.display = 'grid';
        startBtn.classList.remove('pulse');
        updateProgress(0, 'Initializing...');
        
        if (downloadChart) {
            downloadChart.destroy();
            downloadChart = null;
        }
        if (uploadChart) {
            uploadChart.destroy();
            uploadChart = null;
        }
        
        downloadData = [];
        uploadData = [];
        downloadValue.textContent = '0.00';
        uploadValue.textContent = '0.00';
        pingValue.textContent = '0.00';
        jitterValue.textContent = '0.00';
        
        resultsDiv.classList.add('fade-in');
        chartsDiv.classList.add('fade-in');
        
        medianPing = await testLatency();
        if (!testActive) return;
        
        updateProgress(20, 'Calibrating download...');
        const downloadCalibration = await calibrateDownload(medianPing);
        if (!testActive) return;
        
        await testDownload(downloadCalibration, medianPing);
        if (!testActive) return;
        
        updateProgress(60, 'Calibrating upload...');
        const uploadCalibration = await calibrateUpload(medianPing);
        if (!testActive) return;
        
        await testUpload(uploadCalibration, medianPing);
        
        updateProgress(100, 'Test completed!');
    } catch (e) {
        console.error('Test error:', e);
        updateProgress(0, `Error: ${e.message}`);
    } finally {
        testActive = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        startBtn.classList.add('pulse');
    }
}
    
    startBtn.addEventListener('click', runSpeedTest);
    stopBtn.addEventListener('click', () => {
        testActive = false;
        updateProgress(0, 'Test stopped');
        startBtn.disabled = false;
        stopBtn.disabled = true;
        startBtn.classList.add('pulse');
        
        if (downloadChart) {
            downloadChart.destroy();
            downloadChart = null;
        }
        if (uploadChart) {
            uploadChart.destroy();
            uploadChart = null;
        }
    });
    
    document.addEventListener('DOMContentLoaded', () => {
        getClientIP();
        
        Object.keys(localStorage).forEach(key => {
            if (key.startsWith('hfs-geo-') && key.endsWith('_exp')) {
                const expDate = new Date(localStorage.getItem(key));
                if (new Date() > expDate) {
                    const geoKey = key.replace('_exp', '');
                    localStorage.removeItem(geoKey);
                    localStorage.removeItem(key);
                }
            }
        });
    });
</script>
</body>
</html>